{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../type/symbols/index\");\nconst index_8 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_9 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n  return {\n    type: errorType,\n    schema,\n    path,\n    value,\n    message: (0, function_1.GetErrorFunction)()({\n      errorType,\n      path,\n      schema,\n      value\n    })\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) {}\nfunction* FromArray(schema, references, path, value) {\n  if (!(0, index_9.IsArray)(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, index_6.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_8.Never)();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n  if (!(0, index_9.IsAsyncIterator)(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n  if (!(0, index_9.IsBigInt)(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* FromBoolean(schema, references, path, value) {\n  if (!(0, index_9.IsBoolean)(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n  if (!(0, index_9.IsDate)(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* FromFunction(schema, references, path, value) {\n  if (!(0, index_9.IsFunction)(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n  if (!(0, index_9.IsInteger)(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* FromIntersect(schema, references, path, value) {\n  let hasError = false;\n  for (const inner of schema.allOf) {\n    for (const error of Visit(inner, references, path, value)) {\n      hasError = true;\n      yield error;\n    }\n  }\n  if (hasError) {\n    return yield Create(ValueErrorType.Intersect, schema, path, value);\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* FromIterator(schema, references, path, value) {\n  if (!(0, index_9.IsIterator)(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n  if (!(0, index_9.IsNull)(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* FromObject(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise(schema, references, path, value) {\n  if (!(0, index_9.IsPromise)(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n  if (!(0, index_9.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  const regex = new RegExp(schema.source, schema.flags);\n  if (!regex.test(value)) {\n    return yield Create(ValueErrorType.RegExp, schema, path, value);\n  }\n}\nfunction* FromString(schema, references, path, value) {\n  if (!(0, index_9.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if ((0, index_9.IsString)(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if ((0, index_9.IsString)(schema.format)) {\n    if (!index_3.FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = index_3.FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema, references, path, value) {\n  if (!(0, index_9.IsSymbol)(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n  if (!(0, index_9.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* FromThis(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n  if (!(0, index_9.IsArray)(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* FromUndefined(schema, references, path, value) {\n  if (!(0, index_9.IsUndefined)(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n  let count = 0;\n  for (const subschema of schema.anyOf) {\n    const errors = [...Visit(subschema, references, path, value)];\n    if (errors.length === 0) return; // matched\n    count += errors.length;\n  }\n  if (count > 0) {\n    yield Create(ValueErrorType.Union, schema, path, value);\n  }\n}\nfunction* FromUint8Array(schema, references, path, value) {\n  if (!(0, index_9.IsUint8Array)(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* FromUnknown(schema, references, path, value) {}\nfunction* FromVoid(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n  const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[index_7.Kind]) {\n    case 'Any':\n      return yield* FromAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* FromArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* FromAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* FromBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* FromBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* FromConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* FromDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* FromFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* FromInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* FromIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* FromIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* FromLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* FromNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* FromNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* FromNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* FromNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* FromObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* FromPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* FromRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* FromRef(schema_, references_, path, value);\n    case 'RegExp':\n      return yield* FromRegExp(schema_, references_, path, value);\n    case 'String':\n      return yield* FromString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* FromSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* FromTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* FromThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* FromTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* FromUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* FromUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* FromUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* FromUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* FromVoid(schema_, references_, path, value);\n    default:\n      if (!index_3.TypeRegistry.Has(schema_[index_7.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* FromKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n  const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n  return new ValueErrorIterator(iterator);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ValueErrorIterator","ValueErrorsUnknownTypeError","ValueErrorType","Errors","index_1","require","index_2","index_3","extends_undefined_1","function_1","index_4","index_5","index_6","index_7","index_8","index_9","TypeBoxError","constructor","schema","EscapeKey","key","replace","IsDefined","undefined","iterator","Symbol","First","next","done","Create","errorType","path","type","message","GetErrorFunction","FromAny","references","FromArray","IsArray","Array","minItems","length","ArrayMinItems","maxItems","ArrayMaxItems","i","Visit","items","uniqueItems","set","Set","element","hashed","Hash","has","add","ArrayUniqueItems","contains","minContains","maxContains","containsSchema","Never","containsCount","reduce","acc","index","ArrayContains","IsNumber","ArrayMinContains","ArrayMaxContains","FromAsyncIterator","IsAsyncIterator","AsyncIterator","FromBigInt","IsBigInt","BigInt","exclusiveMaximum","BigIntExclusiveMaximum","exclusiveMinimum","BigIntExclusiveMinimum","maximum","BigIntMaximum","minimum","BigIntMinimum","multipleOf","BigIntMultipleOf","FromBoolean","IsBoolean","Boolean","FromConstructor","returns","prototype","FromDate","IsDate","Date","exclusiveMaximumTimestamp","getTime","DateExclusiveMaximumTimestamp","exclusiveMinimumTimestamp","DateExclusiveMinimumTimestamp","maximumTimestamp","DateMaximumTimestamp","minimumTimestamp","DateMinimumTimestamp","multipleOfTimestamp","DateMultipleOfTimestamp","FromFunction","IsFunction","Function","FromInteger","IsInteger","Integer","IntegerExclusiveMaximum","IntegerExclusiveMinimum","IntegerMaximum","IntegerMinimum","IntegerMultipleOf","FromIntersect","hasError","inner","allOf","error","Intersect","unevaluatedProperties","keyCheck","RegExp","KeyOfPattern","valueKey","getOwnPropertyNames","test","IntersectUnevaluatedProperties","FromIterator","IsIterator","Iterator","FromLiteral","const","Literal","FromNever","FromNot","not","Not","FromNull","IsNull","Null","FromNumber","TypeSystemPolicy","IsNumberLike","Number","NumberExclusiveMaximum","NumberExclusiveMinimum","NumberMaximum","NumberMinimum","NumberMultipleOf","FromObject","IsObjectLike","minProperties","ObjectMinProperties","maxProperties","ObjectMaxProperties","requiredKeys","isArray","required","knownKeys","properties","unknownKeys","requiredKey","includes","ObjectRequiredProperty","additionalProperties","ObjectAdditionalProperties","knownKey","property","ExtendsUndefinedCheck","IsExactOptionalProperty","FromPromise","IsPromise","Promise","FromRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","propertyKey","propertyValue","FromRef","Deref","FromRegExp","IsString","String","minLength","StringMinLength","maxLength","StringMaxLength","source","flags","FromString","pattern","StringPattern","format","FormatRegistry","Has","StringFormatUnknown","Get","StringFormat","FromSymbol","IsSymbol","FromTemplateLiteral","FromThis","FromTuple","Tuple","TupleLength","FromUndefined","IsUndefined","Undefined","FromUnion","count","subschema","anyOf","errors","Union","FromUint8Array","IsUint8Array","Uint8Array","maxByteLength","Uint8ArrayMaxByteLength","minByteLength","Uint8ArrayMinByteLength","FromUnknown","FromVoid","IsVoidLike","Void","FromKind","check","TypeRegistry","Kind","references_","$id","schema_","args"],"sources":["C:/Users/kdh99/hopper-game/node_modules/@sinclair/typebox/build/cjs/errors/errors.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../type/symbols/index\");\nconst index_8 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_9 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value) {\n    return { type: errorType, schema, path, value, message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value }) };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!(0, index_9.IsArray)(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, index_6.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_8.Never)();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!(0, index_9.IsAsyncIterator)(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!(0, index_9.IsBigInt)(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!(0, index_9.IsBoolean)(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!(0, index_9.IsDate)(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!(0, index_9.IsFunction)(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!(0, index_9.IsInteger)(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    let hasError = false;\n    for (const inner of schema.allOf) {\n        for (const error of Visit(inner, references, path, value)) {\n            hasError = true;\n            yield error;\n        }\n    }\n    if (hasError) {\n        return yield Create(ValueErrorType.Intersect, schema, path, value);\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!(0, index_9.IsIterator)(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!(0, index_9.IsNull)(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!(0, index_9.IsPromise)(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    if (!(0, index_9.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!(0, index_9.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if ((0, index_9.IsString)(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if ((0, index_9.IsString)(schema.format)) {\n        if (!index_3.FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = index_3.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!(0, index_9.IsSymbol)(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!(0, index_9.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!(0, index_9.IsArray)(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!(0, index_9.IsUndefined)(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    let count = 0;\n    for (const subschema of schema.anyOf) {\n        const errors = [...Visit(subschema, references, path, value)];\n        if (errors.length === 0)\n            return; // matched\n        count += errors.length;\n    }\n    if (count > 0) {\n        yield Create(ValueErrorType.Union, schema, path, value);\n    }\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!(0, index_9.IsUint8Array)(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[index_7.Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}